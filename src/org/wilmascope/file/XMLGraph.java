/*
 * The following source code is part of the WilmaScope 3D Graph Drawing Engine
 * which is distributed under the terms of the GNU Lesser General Public License
 * (LGPL - http://www.gnu.org/copyleft/lesser.html).
 *
 * As usual we distribute it with no warranties and anything you chose to do
 * with it you do at your own risk.
 *
 * Copyright for this work is retained by Tim Dwyer and the WilmaScope organisation
 * (www.wilmascope.org) however it may be used or modified to work as part of
 * other software subject to the terms of the LGPL.  I only ask that you cite
 * WilmaScope as an influence and inform us (tgdwyer@yahoo.com)
 * if you do anything really cool with it.
 *
 * The WilmaScope software source repository is hosted by Source Forge:
 * www.sourceforge.net/projects/wilma
 *
 * -- Tim Dwyer, 2001
 */
package org.wilmascope.file;

import java.io.*;
import org.w3c.dom.*;
import org.xml.sax.*;
import javax.xml.parsers.*;
import java.util.Vector;

// For write operation
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
/** Class for loading and accessing xml enrolment data for the
 * Enroller.
 *
 * @author Tim Dwyer
 * @version 1.0
 */
public class XMLGraph
{
  private Document doc;
  private DocumentBuilderFactory factory;
  private String fileName;
  private Element root;
  /** Create and load the Graph data structures from the data held
   * in the specified file
   * @param fileName the name of the xml file containing the graph data
   */
  public XMLGraph(String fileName) {
    this.fileName = fileName;
    factory = DocumentBuilderFactory.newInstance();
  }
  public void create() {
    try {
      DocumentBuilder builder = factory.newDocumentBuilder();
      doc = builder.newDocument();
      root = doc.createElement("WilmaGraph");
      Cluster rootCluster = new Cluster();
      root.appendChild(rootCluster.getElement());
      doc.appendChild(root);
    } catch (ParserConfigurationException pce) {
      // Parser with specified options can't be built
      pce.printStackTrace();
    }
  }
  public void load() throws IOException {
    //
    // turn the filename into a fully qualified URL
    //
    String uri = new File (fileName).getAbsolutePath ();
    System.out.println(uri);

    factory.setNamespaceAware(true);
    factory.setValidating(true);
    factory.setIgnoringElementContentWhitespace(true);
    factory.setIgnoringComments(true);

    try {
      DocumentBuilder builder = factory.newDocumentBuilder();
      doc = builder.parse(uri);
     } catch (SAXException sxe) {
       // Error generated by this application
       // (or a parser-initialization error)
       Exception  x = sxe;
       if (sxe.getException() != null)
           x = sxe.getException();
       x.printStackTrace();
    } catch (ParserConfigurationException pce) {
        // Parser with specified options can't be built
        pce.printStackTrace();

    } catch (IOException ioe) {
       // I/O error
       ioe.printStackTrace();
    }
    root = doc.getDocumentElement();
  }

  public abstract class XMLGraphElement {
    private Element element;
    protected XMLGraphElement(String name) {
      element = doc.createElement(name);
    }
    protected XMLGraphElement(Element element) {
      this.element = element;
    }
    protected Element getElement() {
      return element;
    }
    protected void setAttribute(String attribute, String value) {
      element.setAttribute(attribute,value);
    }
    protected void setAttribute(String attribute, float value) {
      setAttribute(attribute,Float.toString(value));
    }
    protected String getAttribute(String attribute) {
      return element.getAttribute(attribute);
    }
    protected float getFloatAttribute(String attribute) {
      return Float.parseFloat(getAttribute(attribute));
    }
    protected void createElement(String name) {
      element = doc.createElement(name);
    }
    protected NodeList getChildNodes() {
      return element.getChildNodes();
    }
    protected void appendChild(XMLGraphElement child) {
      element.appendChild(child.getElement());
    }
    protected Colour getColour() {
      NodeList children = getElement().getChildNodes();
      // I'd rather use something like getElementsByTagName but that seems to
      // do a pre-order traversal of the entire element tree rather than just
      // searching the immediate children.  Obviously with nested clusters
      // this would cause trouble
      for(int i=0;i<children.getLength();i++) {
        Element e = (Element)children.item(i);
        if(e.getNodeName().equals("Colour")) {
          return new Colour(e);
        }
      }
      return null;
    }
    protected String getData() {
      return getAttribute("Data");
    }
    protected void setData(String data) {
      setAttribute("Data",data);
    }
    protected String getViewType() {
      return getAttribute("ViewType");
    }
    protected void setViewType(String type) {
      setAttribute("ViewType",type);
    }
    protected void setColour(float red, float green, float blue) {
      appendChild(new Colour(red,green,blue));
    }
    protected void setColour(java.awt.Color colour) {
      float rgb[] = colour.getRGBColorComponents(null);
      appendChild(new Colour(rgb[0],rgb[1],rgb[2]));
    }
  }
  /** wrapper class to access enrolment details for a whole day from
   * the xml data in memory.
   */
  public class Cluster extends Node {
    protected Cluster() {
      super("Cluster");
    }
    protected Cluster(Element clusterElement) {
      super(clusterElement);
    }
    public float getRadius() {
      return getFloatAttribute("Radius");
    }
    public void setRadius(float radius) {
      setAttribute("Radius",radius);
    }
    public void getChildren(
      Vector nodes,
      Vector edges,
      Vector forces,
      Vector clusters
    ) {
      NodeList children = getChildNodes();
      for(int i=0;i<children.getLength();i++) {
        if(!(children.item(i) instanceof Element)) {
          continue;
        }
        Element child = (Element)children.item(i);
        String tagName = child.getTagName();
        if(tagName.equals("Node")) {
          nodes.add(new Node(child));
        } else if(tagName.equals("Edge")) {
          edges.add(new Edge(child));
        } else if(tagName.equals("Force")) {
          forces.add(new Force(child));
        } else if(tagName.equals("Cluster")) {
          clusters.add(new Cluster(child));
        }
      }
    }
    /** add a name to this timeslot
     * @param enrolledName the name of the person to add to the
     * list
     */
    public Node addNode() {
      Node node = new Node();
      appendChild(node);
      return node;
    }
    public Cluster addCluster() {
      Cluster newCluster = new Cluster();
      appendChild(newCluster);
      return newCluster;
    }
    public Edge addEdge(String startID, String endID) {
      Edge edge = new Edge(startID, endID);
      appendChild(edge);
      return edge;
    }
    public Force addForce(String type, float strength) {
      Force force = new Force(type,strength);
      appendChild(force);
      return force;
    }
  }
  /** wrapper class for Node details
   */
  private static int idCounter = 0;
  public class Node extends XMLGraphElement {
    protected Node() {
      super("Node");
      setAttribute("ID",createNewID());
    }
    // at this stage the following is for clusters
    protected Node(String type) {
      super(type);
    }
    public void setLabel(String label) {
      setAttribute("Label",label);
    }
    public final String getID() {
      return getAttribute("ID");
    }
    private String createNewID() {
      return "N" + idCounter++;
    }
    protected Node(Element nodeElement) {
      super(nodeElement);
    }
    /** returns the start time for the timeslot
     * @return the start time as a String format HH24:MI
     */
    public String getLabel() {
      return getAttribute("Label");
    }
    /** get the duration of the class or meeting
     * @return an integer number of hours duration
     */
    public float getRadius() {
      return Float.parseFloat(getAttribute("Radius"));
    }
    protected Position getPosition() {
      NodeList children = getElement().getChildNodes();
      // I'd rather use something like getElementsByTagName but that seems to
      // do a pre-order traversal of the entire element tree rather than just
      // searching the immediate children.  Obviously with nested clusters
      // this would cause trouble
      for(int i=0;i<children.getLength();i++) {
        Element e = (Element)children.item(i);
        if(e.getNodeName().equals("Position")) {
          return new Position(e);
        }
      }
      return null;
    }
    protected void setPosition(float x, float y, float z) {
      appendChild(new Position(x,y,z));
    }
  }
  public class Edge extends XMLGraphElement {
    protected Edge(Element edgeElement) {
      super(edgeElement);
    }
    protected Edge(String startID, String endID) {
      super("Edge");
      setAttribute("StartID",startID);
      setAttribute("EndID",endID);
    }
    public String getStartID() {
      return getAttribute("StartID");
    }
    public String getEndID() {
      return getAttribute("EndID");
    }
  }
  public class Force extends XMLGraphElement {
    protected Force(Element forceElement) {
      super(forceElement);
    }
    protected Force(String type, float strength) {
      super("Force");
      setAttribute("Type",type);
      setAttribute("Strength",strength);
    }
    public String getType() {
      return getAttribute("Type");
    }
    public float getStrength() {
      return getFloatAttribute("Strength");
    }
  }
  public class Colour extends XMLGraphElement {
    protected Colour(Element colourElement) {
      super(colourElement);
    }
    protected Colour(float red, float green, float blue) {
      super("Colour");
      setAttribute("Red",red);
      setAttribute("Green",green);
      setAttribute("Blue",blue);
    }
    public java.awt.Color getAWTColour() {
      return new java.awt.Color(getRed(),getGreen(),getBlue());
    }
    public float getRed() {
      return getFloatAttribute("Red");
    }
    public float getGreen() {
      return getFloatAttribute("Green");
    }
    public float getBlue() {
      return getFloatAttribute("Blue");
    }
  }
  public class Position extends XMLGraphElement {
    protected Position(Element positionElement) {
      super(positionElement);
    }
    protected Position(float x, float y, float z) {
      super("Position");
      setAttribute("X",x);
      setAttribute("Y",y);
      setAttribute("Z",z);
    }
    public float getX() {
      return getFloatAttribute("X");
    }
    public float getY() {
      return getFloatAttribute("Y");
    }
    public float getZ() {
      return getFloatAttribute("Z");
    }
  }
  public Cluster getRootCluster() {
    return new Cluster((Element)root.getFirstChild());
  }
  /** write out the updated data
   */
  public void save() {
    try {
      FileWriter out = new FileWriter(fileName);
      // Use a Transformer for output
      TransformerFactory tFactory = TransformerFactory.newInstance();
      Transformer transformer = tFactory.newTransformer();
      transformer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM,"WilmaGraph.dtd");
      DOMSource source = new DOMSource(doc);
      StreamResult result = new StreamResult(out);
      transformer.transform(source, result);
    } catch(Exception e) {
      e.printStackTrace();
    }
  }
}
