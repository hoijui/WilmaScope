
\documentclass[runningheads]{cl2emult}

\usepackage{makeidx}  % allows index generation
\usepackage{graphicx} % standard LaTeX graphics tool
                      % for including eps-figure files
\usepackage{subeqnar} % subnumbers individual equations
                      % within an array
\usepackage{multicol} % used for the two-column index
\usepackage{cropmark} % cropmarks for pages without
                      % pagenumbers
\usepackage{math}     % placeholder for figures
\usepackage{amssymb}     % placeholder for figures
\usepackage{subfigure} % subfigures in one figure

%\usepackage{algorithm2e}
%\usepackage[ruled,algonl]{algorithm2e}
%\setlength{\algomargin}{2.1em}
%\dontprintsemicolon
%\SetInd{0.5em}{1em}
%\SetKwFor{Forall}{forall}{do}{od}
%\SetKwFor{WhileDo}{while}{do}{od}
%\SetKw{Let}{let}

\makeindex            % used for the subject index
                      % please use the style sprmidx.sty with
                      % your makeindex program

%upright Greek letters (example below: upright "mu")
\newcommand{\euler}[1]{{\usefont{U}{eur}{m}{n}#1}}
\newcommand{\eulerbold}[1]{{\usefont{U}{eur}{b}{n}#1}}
\newcommand{\umu}{\mbox{\euler{\char22}}}
\newcommand{\umub}{\mbox{\eulerbold{\char22}}}
\newcommand{\url}[1]{{\small{\tt #1}}}
\newcommand{\avec}[1]{\vec{\overrightarrow{ #1}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%OPTIONAL%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%\usepackage{amstex}   % useful for coding complex math
%\mathindent\parindent % needed in case "Amstex" is used
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%AUTHOR_STYLES_AND_DEFINITIONS%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%Please reduce your own definitions and macros to an absolute
%minimum since otherwise the editor will find it rather
%strenuous to compile all individual contributions to a
%single book file
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
%
\title*{The WilmaScope 3D Graph Visualisation System}
%
%
\toctitle{WilmaScope}
% allows explicit linebreak for the table of content
%
%
\titlerunning{WilmaScope}
% allows abbreviation of title, if the full title is too long
% to fit in the running head
%
\author{Tim Dwyer\inst{1}
\and Peter Eckersley\inst{2}
}
%
\authorrunning{Tim Dwyer and Peter Eckersley}
% if there are more than two authors,
% please abbreviate author list for running head
%
%
\institute{School of Information Technologies,
     Madsen Building F09,
     University of Sydney,
     NSW 2006,
     Australia.
		 E-mail: \url{dwyer@cs.usyd.edu.au}
\and Department of Computer Science \& Software Engineering,
     University of Melbourne,
     Victoria 3010,
     Australia.
		 E-mail: \url{pde@cs.mu.oz.au}}

\maketitle              % typesets the title of the contribution



%\begin{abstract}
%The abstract\index{abstract} should summarize the contents of the paper
%in at least 70 and at most 150 words; neither too long
%nor too short but to the point!
%\end{abstract}

\section{Introduction: The Motivation for Wilmascope}
\label{sec:intro}
\label{motivation}

Despite, or perhaps because of, the extensive research literature on graph
drawing techniques, there is a lack of state-of-the-art, general purpose
visualisation systems, particularly for application to three-dimensional
embeddings.

Graph drawing problems are, of course, existent within an enormous range of
fields; a key motivation for creating a general purpose 3D visualisation
system is to provide easy-to-use components which can be employed by future
software across these application domains.

3D graph visualisation has not yet found the degree of acceptance that
graph drawing in 2D has found.  Probably since 2D graph drawing's
``killer app'' is the printed page or poster\footnote{Certainly the
screen-shots of Wilma's 3D graphics display included in this chapter
do not do 3D visualisation much justice.  Due to their small size and
without the ability to rotate or zoom the scenes the labels are 
difficult to read and their structure is sometimes obscured.}.
Although 3D graphics
technology is improving very quickly it may be that 3D visualisation
will have to await the advent of cheap, ubiquitous holographic,
augmented or virtual reality environments before it gains widespread
acceptance.  However, clever research into this embryonic area will
hopefully produce examples which demonstrate some benefits of 3D
visualisation even using current hardware.  In any case, it will
at least aid in the rapid adoption of the paradigm once today's
science fiction becomes tomorrow's reality.
It was with the hope of supporting such research that Wilma was conceived
and offered as open
source to researchers and experimenters under the GNU Public License.

Within the graph drawing community itself a system may also aspire to 
streamline, elucidate and beautify the work of algorithm design, comparison
and optimisation.  Achieving these benefits requires software that is
flexible, interactive and easily extensible.

In order to provide these benefits as widely as possible, and to guarantee
an enthusiastic culture of user participation, a serious graph visualisation
system should also be {\em Free Software}\cite{stallman92why}.

In this chapter, we describe WilmaScope (or ``Wilma'', for short), a
sophisticated graph visualisation infrastructure, which attempts to meet
these goals.  In Section~\ref{sec:design}, we describe the Wilma
architecture, modular subsystems, and facilities for control by human users
and other software.  Section~\ref{sec:results} demonstrates Wilma in action
with examples of graphical results and domain specific applications.
Finally, Section~\ref{sec:conclusions} reviews Wilma's contribution and
identifies directions for future development.

\section{Design}\label{sec:design}
\subsection{High Level Architecture}
Conceived as a research project with open-ended goals Wilma was
designed to be as flexible and extensible as possible.  The intention
was to allow different components such as new visual representations
for graph elements, interfaces (either graphical user interfaces or
remote programming interfaces) and different 
layout algorithm implementations to be added or removed easily.
Therefore the design needed to decouple these components as much as
possible so that altering one component would have minimal impact on
the other components.

To achieve this we began by exploring the well known {\em
Model-View-Controller} architecture (MVC) \cite{gamma94design}.
Briefly, the three primary components of the MVC architecture are as
follows: 

\begin{description}
\item[Model] the core
of the application, the data and algorithms that automatically modify
the data. 
\item[View] a user interface which displays information
about the model to the user. 
\item[Controller] a separate user
interface that provides methods for the user to manipulate the
application, ie.\ to control the Model.  
\end{description}

Each component's reference to
the other components is via a carefully defined interface which should
not require change when one of the components is modified in some way.  The
standard data flow diagram for the MVC architecture is shown in Figure
\ref{fig-mvc}.

\begin{figure}[h]
  \centering
  \subfigure[MVC Architecture]{
    \label{fig-mvc}
    \includegraphics[width=0.4\textwidth]{figures/mvc.eps}}
  \subfigure[Wilma Architecture]{
    \label{fig-wilmamvc}
    \includegraphics[width=0.5\textwidth]{figures/wilmamvc.eps}}
  \caption{The classic MVC framework and Wilma's utilisation of MVC.}
\end{figure}

In our system the Model component is further broken down into two sub-components:
\begin{description}
\item[Graph] a data structure capable of representing the structure
and state of the graph including its arrangement in space.
\item[Layout Engine] an abstraction of the basic methods required for
an implementation of any layout algorithm that will change the graph's
arrangement in space.
\end{description}

A further requirement for our system is that the graph data model,
the layout engine and the visual representation of the graph elements should be controllable from multiple sources, primarily:
\begin{description}
\item[Graphical User Interface] a user can interactively construct or
edit the graph structure.  The user can also adjust the layout engine parameters and change the visual representation of the graph elements.
\item[File Handler] a previously constructed graph may be loaded from a file.
\item[API Hooks] supports remote control from a program running in another process or possibly on
another machine. 
\end{description}
The Controller component was therefore also broken
down into several sub-components.  A ``bridge'' layer provides a common
programmatic interface to the Model.  The methods provided by this
bridge layer can then be called by either the GUI interface component,
a component providing a CORBA interface for remote access or a component which
can load and save files to an XML format.

Figure \ref{fig-wilmamvc} depicts this expanded MVC architecture for graph
visualisation. 

\subsection{An Object-Oriented Graph Model}
In designing the Graph Model, ie.\ the data structures for storing the
graph and the methods for manipulating them, some common
elements were identified.  From the definitions given in Chapter 
1: a graph consists fundamentally
of nodes and edges.  These are the basic graph elements.  A clustered
graph has nodes which may themselves be graphs, or clusters.

This description of a graph is modelled in a class hierarchy by
defining an abstract class {\em GraphElement} which is implemented by
both the {\em Node} and {\em Edge} classes.  A {Cluster} will inherit
all the properties of the {\em Node} class and also contains an
aggregation of {\em Nodes} and {\em Edges}.  A {Cluster} also contains
a reference to an abstract definition of a {\em LayoutEngine} which
provides a common interface to an implementation of a layout algorithm
for arranging the graph in two or three dimensional space.  Since the
details of the algorithm are kept separate it is easy to mix and match
different layout styles to different graphs or even to clusters within
the one graph.  A similar class hierarchy was developed independently
by Marshall et al.~\cite{marshall00object} around the same time.
Figure \ref{fig-wilmaclasses} shows a UML diagram depicting this
graph class hierarchy, and also shows how this relates to a force
directed {\em LayoutEngine} implementation, discussed further in
Section \ref{sec:forcedirectedlayout}.  In Figure
\ref{fig-wilmaclasses3D} we show a 3D
interpretation of this UML diagram rendered by Wilma.  This application
of the system is described further in \ref{sec:3duml}.

\begin{figure}[h]
  \centering
  \subfigure[UML Class diagram.]{
    \label{fig-wilmaclasses}
    \includegraphics[width=0.35\textwidth]{figures/wilmaclasses.eps}}
  \subfigure[A 3D interpretation of the class hierarchy.]{
    \label{fig-wilmaclasses3D}
    \includegraphics[width=0.55\textwidth]{figures/wilmaclasses3d.eps}}
  \caption{A class hierarchy for the graph model and the classes used
  in the Force Directed Layout Engine implementation.}
\end{figure}

\subsection{User Interface Design}
A screen-shot of the main Wilma window, with labels describing the main
features is shown in Figure \ref{fig-controls}.
The majority of the space in this window is given over to the 3D
canvas in which the graph structure is visualised.  Users may ``fly''
through the virtual space rendered on this canvas by dragging with the
various mouse buttons.  The possible mouse navigation actions (rotate,
zoom and translate) are
shown in the reminder panel at the bottom of the window (which may be
hidden to gain 3D canvas real-estate).
\begin{figure}[h]
  \centering
    \label{fig-controls}
    \includegraphics[width=\textwidth]{figures/wilmacontrols.eps}
    \caption{The main WilmaScope window}
\end{figure}

The user may also navigate through the cluster hierarchy through this
window.  Clusters are generally shown as transparent spheres or other
convex shapes enveloping the nodes in the cluster.  Right clicking on a
cluster opens a pop-up menu in which the user may choose to expand or
collapse that cluster.  Collapsing the cluster removes its contents
from the 3D scene, shrinks the cluster glyph to a
size proportional to the sum of the mass of its child nodes
and makes the (normally transparent) cluster glyph opaque.

For expanded spherical clusters calculating the radius such that all the
cluster's children are enclosed is a simple matter.
We define the geometric distance of a node $v$ from the centroid
$c$ of its parent cluster $C$ as: $d_{cv}$.  The farthest child $n$ from
$c$ is the one for which the condition $d_{cn} >= d_{ci}$ holds for
all $i \in C$.  We usually set the radius of an expanded cluster to
${R_e}(C) = d_{cn} + R(n)$.  Thus the radius of expanded clusters
depends on the layout algorithm used within the cluster and can be
quite large.

We have found that a convenient way to determine the radius of a collapsed cluster
$R_c(C)$ is to assume a volume for the cluster proportional to its
total mass and density $\rho$, where for us density is simply a convenient scale
factor.  The following is obtained from the formula for volume of a
sphere:
\[R_c(C) = \sqrt[3]{\frac{3}{(4d\pi)}\sum_{v \in C}m_v} \] 

This method produces a collapsed cluster whose size gives the user a
feeling for the number of children it contains.  Yet, it is still
compact enough to be useful in the elision of unnecessary detail from
the collapsed parts of a clustered graph.

Note that a cluster's mass is the sum of its children so that a
collapsed cluster's size will reflect the sum of all its descendents
in the cluster tree.  Section \ref{sec:forcedirectedlayout} describes
how this mass is used to layout expanded clusters.

Wilma was conceived as an interactive graph editor and, therefore, there
are a range of basic actions that a user may perform in editing the
graph structure.  A user may add nodes and edges or group nodes into
clusters using the toolbar buttons.  Clicking on the small arrow on a
toolbar button produces a menu from which the default appearance for
new 
graph elements may be selected, see Figure
\ref{fig-defaultnode}.
Some of these actions are modal, for example, clicking the ``add
edge'' button causes a message that prompts the user to ``select two
nodes to join with an edge''.  Left clicking on a node then causes that node
to change colour showing it has been selected.  The user may then
select another node to create the edge or left click on the selected node a
second time to cancel the whole operation.  Adding a cluster is
similar, however, an extra ``OK'' button is displayed.  The user can
then select nodes individually and presses the ``OK'' button to create
a cluster around the selected nodes.
\begin{figure}
\begin{center}
  \label{fig-defaultnode}
  \includegraphics[width=0.5\textwidth]{figures/defaultnode.eps}
  \caption{Setting the default Node}
\end{center}
\end{figure}

Alternately they can make changes to
the graph or change the appearance of particular graph elements by
right
clicking on the nodes, edges or clusters on the 3D Canvas directly.
This brings up a menu of actions which may be performed on the graph
element.  Figure \ref{fig-popupmenus} shows the various pop-up menus.

\begin{figure}
  \label{fig-popupmenus}
  \subfigure[Node]{
    \label{fig-nodemenu}
\scalebox{0.3}{
    \includegraphics{figures/nodemenu.eps}}}
  \subfigure[Edge] {
    \label{fig-edgemenu}
\scalebox{0.3}{
    \includegraphics{figures/edgemenu.eps}}}
  \subfigure[Cluster] {
    \label{fig-clustermenu}
\scalebox{0.3}{
    \includegraphics{figures/clustermenu.eps}}}
  \caption{The pop-up menus that appear when right-clicking on graph
  elements in Wilma}
\end{figure}

\begin{figure}
  %\subfigure[Controls for generating random graphs for testing layout
  %algorithms]{
    %\label{fig-randomcontrols}
%\scalebox{0.3}{
%\includegraphics{figures/wilma-randomcontrols.eps}}}
  \subfigure[Controls for the force directed layout engine]{
    \label{fig-forcecontrols}
\scalebox{0.3}{
    \includegraphics{figures/wilma-forcecontrols.eps}}}
  \subfigure[Controls for the multiscale force directed layout
  engine]{
    \label{fig-multiscalecontrols}
\scalebox{0.3}{
    \includegraphics{figures/wilma-multiscalecontrols.eps}}}
  \subfigure[Controls for the simulated annealing layout engine]{
    \label{fig-simannealcontrols}
\scalebox{0.3}{
    \includegraphics{figures/wilma-simannealcontrols.eps}}}
  \caption{The various layout engine control windows in Wilma.}
\end{figure}

\subsection{3D Graph Elements}
Wilma provides a number of different 3D ``widgets'' or ``glyphs''
representing nodes, edges and clusters.
The MVC architecture allows other custom graph elements to be added
with ease.  The graph element classes defined in the {\em graph}
package, see Figure \ref{fig-wilmaclasses}, each have a reference to
an object implementing the appropriate View interface ({\em NodeView, EdgeView or ClusterView}).
Custom glyphs for these components need only implement these
interfaces.  Abstract convenience classes that implement these
interfaces with default methods can be extended to define new glyphs
with very little new code.

We briefly describe some of the glyphs so far designed for Wilma:
\begin{description}
\item[Defaults]  The standard glyph for nodes and clusters is a sphere
and the default
edge glyph is a simple cylinder.  Such primitive shapes are useful
because they look the same from all viewpoints.  Level of Detail (LOD)
scaling is used to improve rendering speed, thus maintaining high
frame rates when the scene is rotated or zoomed.  The underlying
framework of all 3D shapes is a triangular mesh.  LOD scaling reduces
the total number of triangles that need to be displayed at any one
time by drawing shapes distant from the view point in a courser fashion.
This is, of course, at the expense of the additional video memory
required to store both the detailed and course triangular meshes.

By default labels appear as banners hovering above the nodes and edges.  These
banners rotate to face the viewpoint so that
they may be read even as the scene is being rotated. 
\item[Nodes]  Different applications require different node
representations.  For example, the 3D UML model shown in Figure
\ref{fig-wilmaclasses3D} uses boxes to represent UML classes.  The
class name is texture mapped onto the surface of the box and in a
similar fashion to the banner labels described above the boxes rotate
to face the user.  In order to enhance the 3D effect the edges of the
boxes are bevelled.  An application that uses cylindrical nodes is
described in Section \ref{sec:fmflow}.  As can be seen in the example
the top and bottom radii of
these cylinders may be adjusted.
\item[Edges] In addition to the basic cylindrical edge we have arrows
for representing directed edges.  The head of the arrow is shown with a cone
indicating direction.

A very efficient way to represent larger graphs is to not show the
nodes at all and use only line segments to show the edges.  3D Graphics
hardware can store a large set of vertices joined by line segments as
a single 3D shape without surface normals.  Not rendering the
surfaces means graphs with tens of thousands of nodes can easily be viewed in
their entirety.  This style of rendering is shown in Figure
\ref{fig-multiscale}.

In Wilma multiple edges joining a pair of nodes are displayed slightly
offset, an example of which can be seen in Figure \ref{fig-controls}.

\item[Clusters] So far clusters have been represented with simple
transparent 3D
primitives: spheres and boxes.  Figure \ref{fig-spincluster} shows a
style of cluster in which nodes are constrained to lie on a plane
inside the cluster.  Again we use a simple transparent sphere but the
constraint plane is also highlighted with a transparent surface inside
the cluster.

A more ambitious representation of a cluster might be a convex hull
surrounding the cluster's children.  Such a representation
would probably be too computationally intensive to allow animated
changes to the positions of the cluster's contents.  However, it may
be useful to show collapsed clusters in this way.  Thus some of the
cluster's internal structure would still be visible even when the
individual nodes have been elided.

\end{description}


\subsection{Platform}

WilmaScope has been implemented in Java, using the Java3D graphics library.
Java provides a good tradeoff between high level language constructs,
portability and performance.  Java3D provides access to 3D graphics accelerator hardware through
a high-level Java API and useful features such as a scene graph
structure and methods for coupling animation into the render cycle.

\subsection{Layout Algorithms}
\subsubsection{Force Directed} \label{sec:forcedirectedlayout}
The first layout algorithm implemented in Wilma was force-directed
layout the basic principles of which are described in Chapter
1.  There were several factors that led us to
implement this algorithm first, notably:
\begin{itemize}
\item it is relatively easy to obtain good results for most types of
graphs by application of the basic attractive spring force and
repulsive inter-node force.
\item it is easy to animate the layout process in a dynamic
graph visualisation to preserve a user's ``mental map''\cite{Misue:VLC95}
between changes in the graph structure.  We can animate simply by
redrawing the graph between each iteration of the algorithm.
\item since the algorithm is iterative and does not require any
special pre- or post-processing it is easy to use in a dynamic graph
editor where the graph structure may be changed by the user even
before the layout has stabilised.
\item different layout
aesthetics can be enhanced by adding extra forces such as the Sugiyama and Misue\cite{Sugiyama:VLC95}
directed field force for aligning directed edges to emphasise flow.
\item the force-directed approach can be easily extended to support
clustered graphs\cite{Huang:GD98}.
\item the approach works just as well in three dimensions as in two.
\end{itemize}
The Wilma implementation of the force-directed algorithm attempts to make the most
of all of these advantages.  Firstly, it offers a user interface which
allows the user to control all the parameters of the layout algorithm
even while the layout is still in progress.  The user can control the
number of iterations of the algorithm that are executed between frames
of animation, choosing to run the algorithm to
convergence as fast as possible or to watch the layout unfold, and if
necessary tweak the controls to adjust the layout or to help it
converge.

Different forces, such as the directed field force or
a gravitational force which keeps the graph centred, may be added or removed
at any time to achieve different aesthetic effects.  Our architecture
achieves this interchangeability of forces by requiring every force to
implement a common interface.  Figure
\ref{fig-wilmaclasses} gives the UML class diagram for the
force-directed layout engine in which this architecture can be seen.

The force-directed layout engine fits well into Wilma's object
oriented clustered graph model.  As mentioned previously each cluster
has its own layout engine but, when the force directed engine is used,
edges connecting nodes in different clusters exert a force on
the nodes inside these clusters.  The nodes inside a cluster are
attracted to the centroid of the cluster by a ``gravitational force''.
The gravitational force then balances the inter-cluster forces.  This
achieves a net result similar to the ``dummy node'' approach of Huang
and Eades\cite{Huang:GD98}, however, repulsive forces do not need to be
calculated between nodes inside different clusters.

As noted previously a cluster's mass is the sum of the masses of all
its children.
The repulsive force used considers the mass of nodes such
that nodes with large mass, for example clusters with many descendents,
will exert a strong repulsive force on their neighbours, ie.\ 
\[ \mathit{repulsiveforce}(p_u,p_v) \equiv \frac{m_u m_v}{\|p_u-p_v\|}
\centerdot \avec{p_u p_v} \]
This ensures
that clusters have plenty of space and avoids overlaps.  It also helps
to give the user a feeling for the size of collapsed clusters.  That
is, even
though their contents is elided the space around them gives an
indication as to their complexity.

A novel extension that has been added to our force-directed layout
engine is the ability for the contents of clusters to be constrained
to a plane.  The orientation of this plane can then be rotated in
order to help minimise the spring force of inter-cluster edges.  This
is illustrated in Figure \ref{fig-spincluster}.  Restricting the
contents of clusters to planes, but then allowing the clusters
themselves to be arranged in three dimensions, allows certain types of
clustered
graphs to be more clearly displayed.  For example, a graph which is not
{\em c-planar}\cite{Eades:GD96} but which has planar clusters may be best
displayed in this way, showing planarity where possible but avoiding
intersecting edges.
\begin{figure}[h]
  \centering
    \includegraphics[width=0.8\textwidth]{figures/enterprise.eps}
  \caption{A screen-shot showing a clustered graph with planar
  clusters.  The clusters are rotated to minimise the lengths of the
  edges between clusters.}
  \label{fig-spincluster}
\end{figure}

\subsubsection{Fast Simulated Annealing}

As stated in Section~\ref{motivation}, a major design goal for Wilma
was to provide a platform upon which algorithmic experimentation could be
conducted elegantly and efficiently.

Force-directed layout algorithms are of course the method of choice for a
wide range of graph visualisation problems.  One variation on these
algorithms, advocated by Fruchtermann \&
Rheingold~\cite{fruchtermann90force-directed} and Davidson et
al.~\cite{davidson01noise}, attempts to avoid calculation of repulsion force
vectors, which is $O(n)$ in the number of vertices for each node $i$, and
$O(n^2)$ for the whole graph:

\begin{equation}
\label{repulsion}
\avec{R_i} \equiv \sum_{j \in V \setminus \{i\}} \avec{r_{ij}}
\end{equation}

\noindent Where $\avec{r_{ij}} = \avec{r_i} - \avec{r_j}$ is the displacement
of node $i$ relative to $j$.

To avoid this expense it is possible to approximate scalar energy potential
values, caching this information at grid points throughout space.  Iterated
updates to the potential well then cost only $O(|V|)$ time per iteration.  On
the downside, the cache array itself takes $O(v \centerdot \rho)$ memory,
where $v$ is the $n$-dimensional volume (or area) of the embedded graph and
$\rho$ is the density of stored potential data points.

Cowling~\cite{cowling02fast} has implemented a fast layout engine for
WilmaScope which employs simulated annealing with potential energy caching to
achieve linear-time graph embeddings.  Cowling was able to demonstrate that
the algorithms of \cite{davidson01noise} do appear to achieve linear time
results.  However, when the grid size $v \centerdot \rho$ must be adjusted to
prevent folding in large graphs, space and time complexity are no longer
linear.  Figure \ref{fig-fastlayout} shows before and after screen-shots of
the algorithm's effects.

Cowling's work serves to demonstrate the utility of Wilma as an empirical
platform; with the WilmaScope rendering and navigation system, and the
availability of convenient data structures for input and dataset management,
algorithmic experiments can be performed at optimal speeds.

\begin{figure}[h]
  \centering
  \subfigure[After only a few iterations.]{
    \label{fig-fastlayout1}
    \includegraphics[width=0.4\textwidth]{figures/fastlayout1.eps}}
  \subfigure[After a complete run of the algorithm.]{
    \label{fig-fastlayout2}
    \includegraphics[width=0.4\textwidth]{figures/fastlayout2.eps}}
  \caption{These screen-shots demonstrate the effects of the simulated
  annealing algorithm with potential caching.  Note that the colour of
  the nodes indicates the force potential at that location.}
  \label{fig-fastlayout}
\end{figure}


\subsubsection{Multiscale Force Directed}

Although the fast simulated annealing approach described above did not prove
perfect as a universal replacement for iterated, force-directed layout, there
are other algorithms in the literature which might be brought to bear.

We have implemented one of these - the ``Multilevel Force-Directed'' approach
of Walshaw~\cite{walshaw00multilevel}.  This multi-scaled approach
incorporates two main innovations over the common force-directed
algorithm -- hierarchical layout, and short-range-only repulsion forces.

Instead of laying out the entire graph from singular or random initial
conditions, the algorithm creates a series of simplified approximations of
the graph, and embeds each of these with increasingly fine detail.

The simplified approximations are generated by applying matching algorithms,
which select at each iteration as many edges as possible such that
no node is connected to two of these edges.  Each edge is then ``collapsed''
so that the two nodes at either end are combined, and the process is repeated.

In order to perform these simplifications rapidly the stochastic matching
approach of Hendrickson \& Leland~\cite{hendrickson95multilevel} is employed.
This takes $O(|V| \centerdot {|E| \over |V|})$ time and is linear for
sparse graphs.

After each level of force-directed layout has stabilised the aggregated
nodes are replaced by their pairs of matched children and the thermal energy
of the system is re-initialised.  This process repeats until the entire graph
has been embedded.

The multilevel process provides a number of benefits over single-pass
force-directed layout.  Notably, these include avoidance of local energy minima
which may result from the arbitrary initial position of a large set of nodes;
and the ability to tune layout parameters to correct for pathologies which
become apparent to the user as the level of detail increases.

Walshaw's algorithm also addresses the $O(n^2)$ cost of calculating the
repulsion force (see Equation~\ref{repulsion}).  As with the fast simulated
annealing strategy this involves storing information about the repulsion in
a spatial data structure although the details are different.

Instead of trying to approximate the potential field of the force the
spatial structure simply allows nodes to be addressed by their locality (or
``cell'').  A na\"{i}ve method for doing this is to keep lists of nodes in a
complete spatial array.  The size of an array may become large relative to
the number of nodes (especially for spacious 3D embeddings) but, if this is
problematic, space usage can be made linear in the number of nodes in
exchange for a constant slowdown through the use of a hash table.

If the repulsion force is constructed so that it cuts off beyond a certain
distance $d_\infty$, that is:

\begin{equation}
\exists \, d_\infty : \, 
||\avec{r_i} - \avec{r_j}|| > d_\infty
\Rightarrow 
repulsionforce (\avec{r_i},\avec{r_j}) = \avec{0}
\end{equation}
%\forall d > d_\infty, f_g(d) = 0

It is then possible to calculate the repulsion force on a particular node $i$
with reference solely to the positions of nearby nodes.  If the cells for
the spatial data structure are of a size greater than or equal to $d_\infty$
then all such nodes may be addressed through the cell containing $i$ and
those adjacent to it.  In this algorithm the cost of calculating the
repulsion force is $O(|V| \centerdot \rho)$, where $\rho$ is the average 
of the embedding density around each node.  Provided that the repulsion
force is {\em strong} --- it does not fall off faster than the square
of the distance between nodes --- then we can expect $\rho$ to be bounded
independently of $|V|$ and repulsion force evaluation to therefore be linear.

The multilevel force-directed layout engine provides WilmaScope with
an efficient mechanism for handling large graphs.  Figure
\ref{fig-multiscale} gives six screen shots showing the progressive
addition of detail as a large graph is embedded using the Wilma multiscale
layout engine.  Figure \ref{fig-multiscalecontrols} shows the full
control panel for the multiscale layout engine.  Each of these
parameters may be adjusted as the layout progresses and the effect
instantly seen on screen.

\begin{figure}[h]
  \centering
  \subfigure{
    \includegraphics[width=0.3\textwidth]{figures/multiscale1.eps}}
  \subfigure{
    \includegraphics[width=0.3\textwidth]{figures/multiscale2.eps}}
  \subfigure{
    \includegraphics[width=0.3\textwidth]{figures/multiscale3.eps}}
  \subfigure{
    \includegraphics[width=0.3\textwidth]{figures/multiscale4.eps}}
  \subfigure{
    \includegraphics[width=0.3\textwidth]{figures/multiscale5.eps}}
  \subfigure{
    \includegraphics[width=0.3\textwidth]{figures/multiscale6.eps}}
  \caption{Six screen shots showing the progress of the Wilma
  multiscale layout engine as it finds an embedding for a regular mesh
  containing 900 nodes.}
  \label{fig-multiscale}
\end{figure}

\subsubsection{DOT: Hierarchical Layout}
DOT is a program included in the Graphviz
(\url{http://www.graphviz.org}) open source graph visualisation
toolkit from AT\&T.  It produces effective two dimensional layered graph
layouts using a Sugiyama\cite{Sugiyama81methods}-style algorithm.
The Wilma DOT layout engine runs dot in a sub-process, pipes in the graph
data converted into DOT file format and parses the DOT output to
obtain the new layout.
DOT also features aesthetically pleasing spline edges which Wilma
is able to render as curved tubes.

Since the DOT layouts are strictly two-dimensional we are free to use the
third dimension to capture additional information.  For example
Section \ref{sec:fmflow} describes an application where the third
dimension (the {\em z}-axis) is used to capture changes in the graph over time.
That is, the nodes are rendered as tubes and the edges may appear at different
levels in the {\em z} dimension.

\subsection{Programming Interfaces}
\label{API}

A key design goal for Wilma was the provision of graph visualisation
facilities for other programs with very low barriers to development.  In order
to achieve this we have implemented two external-access APIs which give
programmers the ability to call up, extend and manipulate graph visualisations
in real-time.  These are the WilmaChat graph definition language, and the
Wilma CORBA interface.

\subsubsection{WilmaChat: A Dialogue on Graph Structure}

The simplest and lowest-energy programming interface to Wilma is the WilmaChat
language.  WilmaChat operates by invoking a server daemon which listens on a
socket or pipe on the machine in question.

Clients can connect to WilmaChat and control graphs by passing commands
in a simple language which allows them to instantiate arbitrary graph
structures.

The advantage of WilmaChat is that it requires extremely little infrastructure
from the developer's programming environment.  The ability to traverse
internal graph structures and print a simple, formalised description of them
is enough to produce navigable 3D output.

\subsubsection{The Wilma CORBA Interface}

While the WilmaChat language is extremely efficient for rapid application
development and can be driven by any programming environment on Wilma's
supported platforms there are a number of advanced features for which the
socket dialogue is an inefficient mode of interaction.  For example, if
developers want multiple clients to connect to a particular Wilma server in
the presence of access-control mediation; or if they wish to allow for
two way communication such that user interaction with the graph in
Wilma is communicated back to the remote application --- then the use
of a custom language requires more overhead.

In order to meet these more sophisticated requirements we have implemented a
Wilma control interface which sits atop CORBA (the Common Object Request
Broker Archicture --- see \url{http://www.corba.org}).  Since CORBA provides
its own access control mechanisms, and good CORBA bindings handle all the
marshaling and type requirements for a sophisticated API, programmers using
languages which support CORBA can take advantage of these facilities without
writing additional code.

\section{Applications: The Importance of being Wilma}
\label{sec:results}
Wilma was designed to be as open and extensible as possible and
evidence for the success of this design is shown in the array of
domains to which Wilma has been applied.

\subsection{3D UML Visualisation} \label{sec:3duml}
The first application of Wilma was an investigation into a 3D
extension of the Unified Modelling Language\cite{dwyer013D-UML}.
UML diagram elements were translated into 3D glyphs and a simple
class-diagram editor was constructed on top of the Wilma framework.  A user study
was then conducted to test the feasibility of such a paradigm for
software design.  Interesting annecdotal evidence was collected
indicating that such 3D UML models, when coupled with a force directed
layout engine, could assist a software architect to understand structure
within a reasonably complex system.  An example of such a diagram is
shown in Figure \ref{fig-wilmaclasses3D}.

\subsection{Fund Manager Flow Visualisation} \label{sec:fmflow}
Most stock market visualisations involve a fairly straightforward
mapping of share attributes into two- or three-dimensional space.  The most
obvious example is share price time series charts.  In an experiment
into graph based visualisation techniques for stock market data
Dwyer~\cite{dwyer02fmflow} defined a graph model for Fund Manager
movement within the stock market.  The graph consists of nodes,
which represent stocks, and edges, which represent a {\em movement} of a
fund manager between a pair of stocks.  Movement from one stock to
another occurs when a fund manager reduces their holding in the first
and increases their holding in the second.

The clients were particularly interested in seeing the changing
behaviour of fund managers over time.  Effectively this means that we
must find some way to visualise a changing graph.  We showed these changes by
arranging the graph for each time period on a plane and then stacking
the time periods in the third dimension.  Nodes representing stocks
are extruded into columns whose width may be varied to indicate a
stock attribute such as unit price.  We call these 3D stacked graph
visualisations {\em stratified graphs}, borrowing the geological term.

Various styles of layout were tried in arranging these stratified
graphs in space.  Force-directed layout was useful for showing clustering and centrality of
highly active stocks while Sugiyama-style layout is useful for showing
flow from source stocks to sinks.  Figure \ref{fig-fm} shows an
example using the DOT layout engine in Wilma to produce 3D Sugiyama-style layout.  A current research project is to tailor the hueristics
used in these layout algorithms to suit such stratified graphs.

\begin{figure}[h]
  \centering
  \subfigure[Perspective view]{
    \label{fig-fmflow}
    \includegraphics[width=0.5\textwidth]{figures/dot_waterlevel2.eps}}
  \subfigure[Side view]{
    \label{fig-fmflow}
    \includegraphics[width=0.4\textwidth]{figures/dot_waterlevel2_sideview.eps}}
  \caption{A visualisation of fund manager movement within the UK
  Computer Services sector for five time periods over two weeks in December.}
  \label{fig-fm}
\end{figure}

\subsection{Web Structure Visualisation}

One early application of Wilma was in the representation of web structure, and
to visualising clustering algorithms for categorising such
structure\cite{eckersley2kclassiscope}.

An example of web structure visualisation is shown in Figure~\ref{fig-web}.
This is a dataset collected in 2000 from the website \url{www.linuxlinks.com}.
The clusters are defined over similarity between pages; also note the set of
17 pages (linked to every other page) which form the site's navigation bar.

\begin{figure}
\begin{center}
\scalebox{0.8}{\includegraphics{figures/cluster1.eps}} \\
\caption{WilmaScope Visualisation of Web Site Structure}
\label{fig-web}
\end{center}
\end{figure}

\subsection{Concept Maps}

A common application of automated graph drawing systems is to visualise
``concept map'' graphs or ``semantic webs'' in which nodes represent ideas and edges, the
connections between them.  These models can be useful for recognising
the important concepts which lie at the heart of expansive ontological
frameworks, and for explaining these structures quickly.

Wilma's extensive range of features allows it to produce concept maps
effortlessly and with a number of visual enhancements over simple
embeddings.  One example of this is shown in Figure~\ref{fig-concept}

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{figures/concepts2.eps} \\
\caption{Example of a WilmaScope Concept Map}
\label{fig-concept}
\end{center}
\end{figure}

\section{Conclusions}
\label{sec:conclusions}

We hope that the reader will by now be convinced that WilmaScope presents an
invaluable addition to the graph connoisseur's toolbox.  

Wilma provides its users with animated, interactive 3D rendering, which takes
advantage of modern accelerated graphics hardware.  These facilities are of
course available by other means but Wilma's API and user interface
endeavours to provide them at a minimum of user labour and/or coding.

Wilma has a general-purpose, extensible architecture, enabling creative
experimentation, domain-dependent extensions, and successive layers of
functionality-transparency for users.

Finally, WilmaScope is released under a free software license --- the Lesser
GNU General Public License (\url{http://www.gnu.org/copyleft/lesser.html}),
which maximises benefits for the user community, guarantees an open
development ecology and thus encourages creative input all round.

Although WilmaScope is a mature and featureful package, there are no doubt a
few interesting bugs still to be discovered by enthusiastic users and, since
research in 3D graph drawing techniques is ongoing, we hope that Wilma can
grow and evolve with the field.  Our eventual hope is that the Wilma
user and developer community will grow to the point where the software
will 
continue to evolve and outlive its original authors.

\paragraph{}

So --- see you at \url{www.wilmascope.org}!

%\begin{thebibliography}{7}
%%
%\addcontentsline{toc}{section}{References}
%
%\bibitem{CHT93} Cai, J., Han, X., Tarjan, R.~E.\ (1993)
%An algorithm for the maximal planar subgraph
%problem.
%SIAM J.\ Comput.\ {\bf22}, 1142--1164
%
%\bibitem{DETT99} Di Battista, G., Eades, P., Tamassia, R., Tollis,
%  I.~G.\ (1999)
%Graph Drawing: Algorithms for the visualization of graphs.
%Prentice Hall, New Jersey
%
%\bibitem{Dji95} Djidjev, H.~N.\ (1995)
%A linear algorithm for the maximal planar subgraph problem.
%Proc.\ 4th Workshop Algorithms Data Struct., 
%Lecture Notes in Computer Science, Springer Verlag
%
%\bibitem{Eul1750} Euler, L.\ (1750)
%Demonstratio nonnullarum insignium proprietatum quibus solida hedris
%planis inclusa sunt praedita.
%Novi Comm.\ Acad.\ Sci.\ Imp.\ Petropol.\ {\bf4} (1752-3, published
%1758), 140--160, also: Opera Omnia (1) {\bf26}, 94--108
%
%\bibitem{KW01} Kaufmann, M., Wagner, D. (eds.) (2001)
%Drawing Graphs: Methods and Models.
%Lecture Notes in Computer Science 2025, Springer Verlag
%
%\bibitem{TDB88} Tamassia, R., Di Battista, G., Batini, C.\ (1988)
%Automatic graph drawing and readability of diagrams.
%IEEE Transactions on Systems, Man, and Cybernetics {\bf18}, 61--79
%
%\end{thebibliography}

\bibliographystyle{plain}
\newpage
\addcontentsline{toc}{section}{References}
\bibliography{refs}

%
%INDEX%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\clearpage
%\addcontentsline{toc}{section}{Index}
%\flushbottom
%\printindex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
